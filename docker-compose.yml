version: '3.5'
services:
  db:
    image: postgres:13.0-alpine
    env_file:
      - "config.env"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -q -d ${POSTGRES_DB} -U ${POSTGRES_USER}" ]
      interval: 5s
      timeout: 5s
      retries: 5
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    restart: always

  auth_db:
    image: postgres:13.0-alpine
    env_file:
      - "config.env"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -q -d ${AUTH_POSTGRES_DB} -U ${AUTH_POSTGRES_USER}" ]
      interval: 5s
      timeout: 5s
      retries: 5
    environment:
      - POSTGRES_DB=${AUTH_POSTGRES_DB}
      - POSTGRES_USER=${AUTH_POSTGRES_USER}
      - POSTGRES_PASSWORD=${AUTH_POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/auth_data/
    restart: always

  auth_redis:
    image: redis:7.0.9
    restart: always
    env_file:
      - config.env

  auth_api:
    build: auth_api
    env_file:
      - config.env
    restart: always

  elastic:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.7.0
    restart: always
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://${ELASTIC_HOST}:${ELASTIC_PORT}/" ]
      interval: 5s
      timeout: 5s
      retries: 5
    environment:
      - "discovery.type=single-node"
    volumes:
      - elasticdata:/usr/share/elasticsearch/data
    env_file:
      - config.env

  transfer:
    image: alexanderprm/sqlite_to_postgres:async_api_transfer
    env_file:
      - config.env
    depends_on:
      - db

  etl_movies:
    build: films_api/etl/etl_movies
    restart: always
    env_file:
      - config.env
    depends_on:
      - db
      - elastic
      - transfer

  etl_persons:
    build: films_api/etl/etl_persons
    restart: always
    env_file:
      - config.env
    depends_on:
      - db
      - elastic
      - transfer

  etl_genres:
    build: films_api/etl/etl_genres
    restart: always
    env_file:
      - config.env
    depends_on:
      - db
      - elastic
      - transfer

  redis:
    image: redis:7.0.9
    restart: always
    env_file:
      - config.env
    depends_on:
      - etl_movies
  
  api:
    build: films_api
    ports:
      - 8000:8000
    env_file:
      - config.env
    restart: always
    
  nginx:
    image: nginx:1.22.1
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - auth_db
      - auth_redis
      - auth_api
    ports:
      - 80:80
      
  tracer_jaeger:
    image: jaegertracing/all-in-one:latest
    restart: always
    ports:
      - "6831:6831/udp"
      - "16686:16686"

  ugc:
    build: ugc
    ports:
      - 8001:8000
    env_file:
      - config.env
    restart: always

  ugc_etl:
    build: ugc/src
    env_file:
      - config.env
    restart: always

  zookeeper:
    image: wurstmeister/zookeeper
    restart: always
  
  kafka:
    image: wurstmeister/kafka
    environment:
      - KAFKA_ADVERTISED_HOST_NAME=${KAFKA_ADVERTISED_HOST_NAME}
      - KAFKA_ZOOKEEPER_CONNECT=${KAFKA_ZOOKEEPER_CONNECT}
    restart: always
    depends_on:
      - zookeeper

  ugc_redis:
    image: redis:7.0.9
    restart: always
    env_file:
      - config.env

  zookeeper_ch:
    image: zookeeper:3.5
    container_name: zookeeper_ch
    hostname: zookeeper_ch

  clickhouse-node1:
    image: yandex/clickhouse-server:20.4
    container_name: clickhouse-node1
    hostname: clickhouse-node1
    ports:
      - "8123:8123"
      - "9000:9000"
    volumes:
      - ./clickhouse_config/node1:/etc/clickhouse-server
    depends_on:
      - zookeeper_ch

  clickhouse-node3:
    image: yandex/clickhouse-server:20.4
    container_name: clickhouse-node3
    hostname: clickhouse-node3
    volumes:
      - ./clickhouse_config/node3:/etc/clickhouse-server
    depends_on:
      - zookeeper_ch

volumes:
  clickhouse_config:
    driver: local
    driver_opts:
      type: 'none'
      o: 'bind'
      device: './clickhouse_config'
  postgres_data:
  elasticdata: